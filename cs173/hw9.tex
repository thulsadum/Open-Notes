\documentclass[12pt]{article}
\textwidth = 6.7 in
\textheight = 9.2 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.2 in
\headheight = 0.0 in
\headsep = 0.0 in
\parskip = 0.2in
\parindent = 0.0in

\usepackage{amsmath,amssymb,enumerate,enumerate}
%\def\rmdefault{bch} % Use Charter for main text font.

% =========================================================
\begin{document}

\begin{center}
{\LARGE
\textbf{Marcell Vazquez-Chanlatte}
\\
\textbf{F2}
\\[1ex]}
\end{center}

\begin{enumerate}

%------------------------------------------------------------
\item
\textbf{Recurrences [21 points]}

\begin{enumerate}
\item $A(n)=2A(n/4) + \sqrt{n}$\\
  Observe that each level does $\sqrt(n)$ work.\\
  Also note that the is $\log(n)$ depth to the tree
  Thus  $O(\sqrt(n) \log(n))$\\
\\\\\\\\\\\\\\\\\\\\\\
\item $J(n)=J(n/2) + J(n/6) + J(n/3) + n$\\
  Observe that each level does $n$ work\\
  Also note that the tree has a depth of $log(n)$ (The base is $2$\\
  however the tree is uneven thus this is merely an upperbound)\\
  Thus $O(n*\log(n))$
  \newpage
\item $T(n)=4T(n-1)+2^n$\\
  Notice that the depth is $n$\\
  Observe that each level does $4^i*2^{2-i}$ work where $i$ is the depth.\\
  Thus the total work done is $\displaystyle\sum\limits_{i=0}^n
  4^i*2^{n-i} = 2^n*(2^{n+1} -1)$.\\
  Thus $O(2^{2n+1})$
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\end{enumerate}
%---------------------------------------------
\item
\textbf{Algorithm Analysis [21 points]}

\begin{enumerate}
\item The algorithm below calculates $n!=n*(n-1)*(n-2)*\ldots*1$ \\

Factorial ($n$: non negative integer) 
%\vspace{-0.1in}
\begin{quote}
1.	\hspace{0.1in}	if ($n = 0$ or $n = 1$)   $O(1)$\\
2.	\hspace{0.3in}		return 1 $O(1)$\\
3.	\hspace{0.1in}	return $n \times $Factorial($n-1$) $O(n)$
\end{quote}

The algorithm is $O(n)$. This is because with each recursion, the new
state's $n = n -1$. Thus it requires $n$ time for it to reach the base
case. Everything else is constant therefore $O(n)$
%-------------
\newpage
%-------------

\item
The algorithm below approximates the square root of a positive integer \\

SquareRoot($n$: positive integer)
%\vspace{-0.1in}
\begin{quote}
$L,H,M$ : reals \\
1.	\hspace{0.1in}	$L = 0$ $O(1)$\\
2.	\hspace{0.1in}	$H = n$ $O(1)$\\
3.	\hspace{0.1in}	while ($H - L > 1/10^9$) $O(\log(n)$ ish\\
4.	\hspace{0.3in}		$M = (L+H)/2$ $O(1)$\\
5.	\hspace{0.3in}		if ($M^2 > n$) $O(1)$\\
6.	\hspace{0.5in}			$H = M$ $O(1)$\\
7.	\hspace{0.3in}		else if ($M^2 < n$) $O(1)$\\
8.	\hspace{0.5in}			$L = M$ $O(1)$\\
9.	\hspace{0.3in}		else return $M$ $O(1)$...sometimes never\\
10.	\hspace{0.02in}	return $M$
\end{quote}

This algorithm runs at $O(\log(n))$
Note that until roughly $\log(n)$ times, line $5$ will execute thus
skipping $7-9$\\
Also observe that the remaining interations are few by comparision as
$M-L$ limits to roughly $0$. (easily with a multiple of $\log(n)$)\\
Thus this is $O(\log(n))$
\vspace*{0.2in}
\item

AlmostSorted($a_1,a_2, \ldots , a_n$: array of $n$ integers)
%\vspace{-0.1in}
\begin{quote}
$i$ : integer \\
1.	\hspace{0.1in}	for $i=1$ to $n$ $O(n)$\\
2.	\hspace{0.3in}		min=$a_i$; $O(1)$\\
3.	\hspace{0.3in}		minpos=i; $O(1)$\\
4.	\hspace{0.3in}		for $j=i+1$ to $minimum(i+k,n)$ $O(n)
\vee O(k)$\\
5.	\hspace{0.5in}			if ($a_j < min$) $O(1)$\\
6.	\hspace{0.7in}				min=$a_j$ $O(1)$\\
7.	\hspace{0.7in}				minpos=j $O(1)$\\
8.	\hspace{0.3in}		$swap(a_i,a_{minpos})$ $O(1)$\\
9.	\hspace{0.1in}	return $a_1,a_2, \ldots , a_n$ $O(1)$
\end{quote}

This algorithm is $O(n^2)$. Observe that line $1$ will run $O(n)$
times. Also observe that the inner loop at line $4$ will run either
$O(n) or O(k)$ times. However if $k >= n$ then the loop will go $O(n)$
times because of the $min$ function. Thus the code loops $n^2$
times...and everything else is constant thus $O(n^2)$

\end{enumerate}

%================================================================

\end{enumerate}
\end{document}