% Created 2012-03-15 Thu 14:51
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{amssymb}
\usepackage{hyperref}


\title{CS 373 Notes}
\author{}
\date{15 March 2012}

\begin{document}

\maketitle

\setcounter{tocdepth}{3}
\tableofcontents
\vspace*{1cm}

\section{General}
\label{sec-1}



\begin{center}
\begin{tabular}{lll}
 Sizes                 &  Examples                           &  Countable?  \\
\hline
 Finite                &  \{a,b\}                            &  yes         \\
 Countable Infinite    &  \mathbb{N},\mathbb{Z}, \mathbb{Q}  &  yes         \\
 Uncountable Infinity  &  \mathbb{R}, Pow(\mathbb{R})        &  no          \\
\end{tabular}
\end{center}





\begin{center}
\begin{tabular}{lll}
 name                   &  descriptipn  &  Machine  \\
\hline
 regular                &  LRk          &  D PDA    \\
 context free language  &  CFG          &  PDA      \\
\end{tabular}
\end{center}



\subsection{Starting off}
\label{sec-1.1}

\begin{enumerate}
\item Alphabet($\Sigma$) = finite non empty set
\item \mathbb{N} in this class starts at 0
\item A set X is countably infinite iff $\exists$ a bijection $f:\mathbb{N} \rightarrow X$
\end{enumerate}
\subsection{Strings}
\label{sec-1.2}

\begin{enumerate}
\item String(w) = sequence of characted in $\Sigma$
\item w:\{c$_i$ \in $\Sigma$ | 0 <= i <= n\}
\item |w| = n = length of the string
\item |w| = 0 \rightarrow w = $\epsilon$

\begin{enumerate}
\item Careful $\sigma$ \neq \emptyset
\end{enumerate}

\item Substring subsequence of characters in w
\item Concatination: w$_1$ \cdot w$_2$
\item Reverse: w$^r$
\item Palindrum: w = w$^r$
\end{enumerate}
\subsection{Language}
\label{sec-1.3}

\begin{enumerate}
\item Language(L) = set of strings
\item $\Sigma$$^n$ = \{w : |w| = n\}
\item $\Sigma$$^0$ = \{ $\epsilon$ \}
\item $\Sigma$^* = $\cup$$^n$$_{\mathrm{i=0}}$ $\Sigma$$^i$, Language of all strings
\end{enumerate}
\section{Regular Languages}
\label{sec-2}

\subsection{Deterministic Finite Automotas}
\label{sec-2.1}

\begin{enumerate}
\item Finite state machine (M)
\item Takes a string of inputs
\item 2 types of states

\begin{enumerate}
\item Accept
\item Deny
\end{enumerate}

\item There is 1 start state
\item The set of all strings accepted by language of M or L(A)
\item Formal Definition

\begin{enumerate}
\item a Language A $\in \Sigma^*$ is called regular iff there
        exists a DFA ,M, s.t. $L(M) = A$
\item \A DFA is a 5 tuple \$ M = (Q,$\Sigma$, $\delta$, q$_0$, F)\$

\begin{enumerate}
\item Q is a finte set of states
\item $\Sigma$ is a finite alphabet
\item $\delta: Q\times\Sigma \rightarrow Q$ is the transition function
\item $q_0 \in Q$  is the inital state
\item $F \subset Q$ is the set of accept states
\end{enumerate}

\item L(M) $\equiv$ language of all accepted strings
\end{enumerate}

\item Closure properties/Regular Operations on languages

\begin{enumerate}
\item A$_1$ and A$_2$ are regular
\item Union: A$_1$ $\cup$ A$_2$ = A$_3$
\item Concatenate: A$_1$ A$_2$ = A$_3$
\item Star: A$_1$^* = A$_3$
\end{enumerate}

\end{enumerate}
\subsection{Non-Deterministic Finite Automotas (NFA)}
\label{sec-2.2}

\begin{enumerate}
\item Formal Definition

\begin{enumerate}
\item M = (Q,$\Sigma$,$\delta$,q$_0$,F)

\begin{enumerate}
\item Q = finite set of states
\item $\Sigma$  is a finate alphabet
\item $\delta = Q \times \Sigma_\epsilon \rightarrow Pow(Q)$

\begin{enumerate}
\item $\Sigma_\epsilon = \Sigma \cup {\epsilon}$
\end{enumerate}

\item $q_0$ = start state
\item $F \subset Q$
\end{enumerate}

\item NFA accepts w If we can write $w = {y_1 y_2 ... y_n
         y_i \in \Sigma_\epsilon}$ s.t. there exists a sequence of
         states path $R = {r_0,r_1,...}$

\begin{enumerate}
\item r$_0$ = q$_0$
\item $r_{i+1}\in\delta(r_i,y_{i+1})$ for $i=0,1...m-1$
\item $r_m \in F$
\end{enumerate}

\end{enumerate}

\item Useful Lemma: For all NFA, M, there exists an DFA ,N, s.t. L(m)
      = L(n)
\end{enumerate}
\subsection{Regular Expressions}
\label{sec-2.3}

\begin{enumerate}
\item Def: R is a regex over a fixed alphabet iff one of the
      following is true:

\begin{enumerate}
\item R = a \in $\Sigma$
\item R = $\sigma$
\item $R = \emptyset$
\item \$R = R$_1$ $\cup$ R$_2$,\$ given $R_1 \wedge R_2$ are regex
\item \$R = R$_1$ R$_2$,\$ given $R_1 \wedge R_2$ are regex
\item $R = R^*$
\end{enumerate}

\item Order of operations

\begin{enumerate}
\item star
\item concatination
\item union
\end{enumerate}

\item Identities

\begin{enumerate}
\item $a \emptyset = \emptyset$
\item $a \sigma = \sigma$
\item $\emptyset^* = {\sigma}$
\end{enumerate}

\end{enumerate}
\subsection{Generalized NFA (GNFA)}
\label{sec-2.4}

\begin{enumerate}
\item Definition

\begin{enumerate}
\item Q = set of all states
\item $Q^0 = Q - {q_start, q_accept}$
\item \underline{The} start state has out edges to every $q\in Q - {q_start}$, and
         no in edges
\item \underline{The} accept state has inedges from every $q\in Q - {q_accept}$,
         and no outedges
\item An edege exists from every $q_1\in Q^0$ to every $q_2\in Q^0$
         even if $q_1=q_2$
\item Every edge is labed with a regex
\end{enumerate}

\item Useful lemma: Any NFA can be written as a GNFA
\item lemma: Given a GNFA, M,  with 2 states, the regex between the 2
      states describes the language of M
\end{enumerate}
\subsection{Pumping Lemma for regular languages}
\label{sec-2.5}

  If A is regular, then $\exists p \in \mathbb{N}$ s.t. $\forall s
   \in A$ for which $|s| >= p, s$ can be written as  $xyz$ and
   satisfy the following conidition:
\begin{enumerate}
\item $\forall i >= 0, x y^i z \in A$
\item $|y|>0$ i.e. $y \neq \epsilon$
\item $|xy| <= p$
\end{enumerate}
  P is called the ``pumping length

\subsection{Subsitutions}
\label{sec-2.6}

\subsubsection{Substution simple definition}
\label{sec-2.6.1}

\begin{itemize}
\item A is a reg language and $A \mapsto f(A), A \subseteq E^*$
\item A s described w. a regex and $R_a$ is a regex using $\Gamma$
\item $\forall a \in \Sigma  a \mapsto R_a$
\item $\epsilon \mapsto \epsilon$ and $\emptyset \mapsto \emptyset$
\end{itemize}
\subsubsection{Homomorphism}
\label{sec-2.6.2}

\begin{itemize}
\item $A \mapsto h(A)$
\item $a \mapsto w, w \in \Gamma^*, a\in \Sigma$
\end{itemize}
\subsubsection{Inverse Homorphism}
\label{sec-2.6.3}

\begin{itemize}
\item $h^{-1}(A) = \{w\ \in \Sigma^* | h(w) \in A\}$
\end{itemize}
\subsection{DFA Minimization}
\label{sec-2.7}

\subsubsection{Theory}
\label{sec-2.7.1}

   Problem: Given a DFA, M, with L(M) = A, find another DFA, M$_{\mathrm{2c}}$,
   s.t. L(M) = L(M$_2$) and |Q$_2$| is as small as possible\\
\begin{itemize}
\item \$$\delta$: Q $\times$ $\Sigma$ \rightarrow Q\$\\
     $\bar{\delta(q,w)} q\in Q, w\in \Sigma^*$ \\
     $\bar{\delta(q,w)} \equiv$ interative call on delta for all $w_i$
     in w

     If $\exists w \in \Sigma^*$ s.t. $[\bar{\delta(p,w)} \in F$ and
     $\delta{q,w} \notin F]$ or $[\bar{\delta(p,w)} \notin F$ and
     $\delta{q,w} \in F]$ then p and q are distrguishable
\end{itemize}
\subsubsection{Algorithm}
\label{sec-2.7.2}


\begin{verbatim}
for (p,q) in Q^2:
    if (p in F) and (not q in F):
        A.push((p,q)) # marked list
    else:
        B.push((p,q)) # unmarked list
for (p,q) in B:
    if (delta(p,a),delta(q,a)) in B:
        A.push((p,q))
\end{verbatim}


\subsection{Reg Operations (closed under the Reg languages)}
\label{sec-2.8}

\begin{enumerate}
\item $A_1 \cup A_2$
\item $A_1 - A_2$
\item $\bar{A_1} = \Sigma^* - A_1$
\item $A_1 \cap A_2$
\item Symmetric Diff
\item $A_1 A_2$
\item $A_1^*$
\item $A^r$
\item Reg langagues are clased under subsitution
\item Reg langagues are clased under homomorphism
\item Reg langagues are clased under inverse homorphism
\item Reg langagues are clased under
\end{enumerate}
\section{Context Free Grammars}
\label{sec-3}

\subsection{Formal Definition:}
\label{sec-3.1}

\begin{enumerate}
\item $(V,\Sigma, R, S)$

\begin{enumerate}
\item $V =$ Finite set of \underline{variables} or ``non-terminals''
\item $\Sigma$ =  finite set of \underline{terminals}

\begin{enumerate}
\item $\Sigma \cap V = \emptyset$
\item Convention: Variables are uppercase, symbols are lowercase
\end{enumerate}

\item R = finite set of \underline{rules} or ``subsitution rules'' or ``productions''
         1.Rules: examples

\begin{enumerate}
\item $A \rightarrow aaBc | a$

\begin{enumerate}
\item This means the for an A you can replace it with aaBc or a
\end{enumerate}

\item $A \Rightarrow OA1 \Rightarrow 00A11 \Rightarrow 001A011 \Rightarrow 001011$
\end{enumerate}

\item S is the \underline{start variable}
\end{enumerate}

\item $L(G) = \{w\in \Sigma^* | S \Rightarrow^* w\}$
\item Notation:

\begin{enumerate}
\item Variables: A,B,C\ldots{}
\item Terminal: a,b,c,\ldots{}0,1,\$ $\epsilon$ \$
\item $U \Rightarrow^* V$ is defined as $\exists$ sequence
         $U_1..U_k$ , s.t. $U \Rightarrow U_1 \Rightarrow  U_2
         \Rightarrow ... \Rightarrow U_k \rightarrow V$
\end{enumerate}

\end{enumerate}
\subsection{Chomsky Normal form (CNF)}
\label{sec-3.2}

\begin{itemize}
\item All rules have the form

\begin{itemize}
\item $A\rightarrow BC$, where $B,C$ cannot be $S$
\item $A\rightarrow a$
\item if $A\rightarrow \epsilon$ then $A = S$
\end{itemize}

\item Lemma: Any CFG can be written in CNF
\end{itemize}
\subsection{Deterministic Push Down Automotas}
\label{sec-3.3}

\begin{itemize}
\item $M = (Q,\Sigma, \Gamma, \delta, q_0, F)$

\begin{itemize}
\item $\delta: Q \times \Sigma_\epsilon \times \Gamma_\epsilon
       \rightarrow Q \times \Gamma_\epsilon$
\end{itemize}

\end{itemize}
\subsection{Non-Deterministic Push Down Automotas (PDA)}
\label{sec-3.4}

\begin{itemize}
\item $M = (Q,\Sigma, \Gamma, \delta, q_0, F)$

\begin{itemize}
\item $\delta: Q \times \Sigma_\epsilon \times \Gamma_\epsilon
       \rightarrow Pow(Q \times \Gamma_\epsilon)$
\end{itemize}

\end{itemize}
\subsection{Relating PDA to CFL}
\label{sec-3.5}

\begin{itemize}
\item A language is context free iff $\exists$ a PDA that recognizes it

\begin{itemize}
\item Lemma: If A is CF, then $\exists$ a PDA,$M$, s.t. $A = L(M)$
\item Lemma: $\forall$ PDA, $M$, $\exists$ CFL, $G$, s.t. $L(G)=L(M)$

\begin{itemize}
\item Proof Idea: Make a conical PDA (while preserving acceptance)
         as follows

\begin{enumerate}
\item 1 accept states
\item Stack is empty when accepting
\item Every transition either push or pops but not both
\end{enumerate}

\end{itemize}

\end{itemize}

\end{itemize}
\subsection{Pumping Lemma for CFL's}
\label{sec-3.6}

\subsection{Closure Properties of CFL's}
\label{sec-3.7}

\begin{enumerate}
\item A$_1$ $\cap$ A$_2$
\item A$_1$ \cdot A$_2$
\item A$_1$$^{\star}$
\item Closure under substituion
\end{enumerate}
\subsubsection{Theorems for Closure}
\label{sec-3.7.1}

    Let G$_i$ = (V$_i$, $\Sigma$$_i$, R$_i$, S$_i$) for i=1,2 and A$_i$ =
    L(G$_i$)\\
    Without loss of generality, assume V$_1$ $\cap$ V$_2$ = \emptyset \wedge
    S$_3$
    
\begin{itemize}

\item Theorem: If A$_1$ and A$_2$ are CFL's, then A$_1$ $\cup$ A$_2$ is a CFL\\
\label{sec-3.7.1.1}

Proof:

    Let G$_i$ = (V$_i$, $\Sigma$$_i$, R$_i$, S$_i$) for i=1,2 and A$_i$ =
    L(G$_i$)\\
    Without loss of generality, assume V$_1$ $\cap$ V$_2$ = \emptyset \wedge
     S$_3$
    $\notin$ V$_1$ $\cup$ V$_2$
    
    Construct G$_3$ = (V$_1$ $\cup$ V$_2$ $\cup$ \{S$_3$\}, $\Sigma$$_1$ $\cup$ $\Sigma$$_2$,
    R$_3$, S$_3$) with \\
    R$_3$= R$_1$ $\cup$ R$_2$ $\cup$ \{S$_3$ \rightarrow S$_1$|S$_2$\}. \square

\item Theorem: If A$_1$ and A$_2$ are CFL's then A$_1$ \cdot A$_2$ is a CFL\\
\label{sec-3.7.1.2}

     Proof:
     
     $\notin$ V$_1$ $\cup$ V$_2$
     Construct G$_3$ = (V$_1$ $\cup$ V$_2$ $\cup$ \{S$_3$\}, $\Sigma$$_1$ $\cup$ $\Sigma$$_2$,
     R$_1$ $\cup$ R$_2$ $\cup$ \{S$_3$ \rightarrow  S$_1$ S$_2$\}, S$_3$)

\item Theorem: If A$_1$ and A$_2$ are CFL's then  A$_1$$^{\star}$ is a CFL\\
\label{sec-3.7.1.3}

     Proof:
     Construct G$_3$ = (V$_1$ $\cup$ \{S$_3$\}, $\Sigma$$_1$, R$_1$ $\cup$ \{S$_2$
     \rightarrow S$_1$ S$_2$ | $\epsilon$ \} )
\end{itemize} % ends low level
\subsection{CYK algorithm}
\label{sec-3.8}


\end{document}